<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>KizarmProbe.: Kizarm Probe.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">KizarmProbe.
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generováno programem Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Hledat');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Hlavní&#160;stránka</span></a></li>
      <li><a href="modules.html"><span>Moduly</span></a></li>
      <li><a href="annotated.html"><span>Třídy</span></a></li>
      <li><a href="files.html"><span>Soubory</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Hledat" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Vše</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Třídy</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Soubory</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funkce</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Proměnné</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Výčty</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Hodnoty výčtu</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Definice maker</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Skupiny</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Stránky</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Kizarm Probe. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Tento projekt je inspirován <a href="http://www.blacksphere.co.nz/main/blackmagic">Blackmagic Probe</a> pro STM32Fxx. Pro procesory NXP něco takového trochu chybí, tak se to pokusíme napravit. Měl by tak vzniknout jednoduchý a levný prostředek pro ladění pomocí SWD založený na čipu LPC11U24 pro řadu LPC11Xxx ale nejen pro ni. Další targety bude možné podle libosti přidávat, zdroj je zcela otevřen pro pokusy.</p>
<dl class="section author"><dt>Autor</dt><dd><ol type="1">
<li>Copyright (C) 2009 Keil - An ARM Company. <br/>
 USB stack pro NXP procesory</li>
<li>Copyright (C) 2011 Black Sphere Technologies Ltd. <br/>
 Gareth McMullin <a href="#" onclick="location.href='mai'+'lto:'+'gar'+'et'+'h@b'+'la'+'cks'+'ph'+'ere'+'.c'+'o.n'+'z'; return false;">garet<span style="display: none;">.nosp@m.</span>h@bl<span style="display: none;">.nosp@m.</span>acksp<span style="display: none;">.nosp@m.</span>here<span style="display: none;">.nosp@m.</span>.co.n<span style="display: none;">.nosp@m.</span>z</a>, gdb server a ARM utility.</li>
<li>Copyright (C) 2014 Miroslav Mráz <a href="#" onclick="location.href='mai'+'lto:'+'mra'+'zi'+'k@v'+'ol'+'ny.'+'cz'; return false;">mrazi<span style="display: none;">.nosp@m.</span>k@vo<span style="display: none;">.nosp@m.</span>lny.c<span style="display: none;">.nosp@m.</span>z</a> <br/>
 Postaveno do tříd C++, upraveno pro GNU toolchain a slepeno dohromady.</li>
</ol>
</dd></dl>
<h1><a class="anchor" id="sectLic"></a>
Licence.</h1>
<p><a href="http://www.gnugpl.cz/">Obecná veřejná licence GNU (GNU GPL), 3. verze</a> <br/>
Tento program je svobodný software: můžete jej šířit a upravovat podle ustanovení Obecné veřejné licence GNU (GNU General Public Licence), vydávané Free Software Foundation a to podle 3. verze této Licence.</p>
<p><b>Tento program je rozšiřován v naději, že bude užitečný, avšak BEZ JAKÉKOLIV ZÁRUKY. Neposkytují se ani odvozené záruky PRODEJNOSTI anebo VHODNOSTI PRO URČITÝ ÚČEL. Další podrobnosti hledejte v Obecné veřejné licenci GNU.</b></p>
<h1><a class="anchor" id="sectHw"></a>
Hardware.</h1>
<p>Bylo již publikováno <a href="http://mcu.cz/comment.php?comment.news.3515">zde</a>. Pinout je trochu podivný (viz. ./lpc11/config.h), takže SWCLK je zde AD0 a SWDIO je AD1. Sériový port, pokud je použit používá normálně piny RXD a TXD.</p>
<h1><a class="anchor" id="sectA"></a>
Jak to vlastně funguje.</h1>
<p>Hojně používaným prostředkem pro ladění jednočipů je <a href="http://openocd.sourceforge.net/">OpenOCD</a>. Je to proto, že podporuje velkou spoustu debug adaptérů (jako je např. ST-Link) a umožňuje ladit širokou škálu cílových, target procesorů. Je to však poněkud nešikovné - musíme to pustit jako server a k němu se z jedné strany připojí laděný procesor a z druhé gdb. <a href="http://www.blacksphere.co.nz/main/blackmagic">Blackmagic</a> to řeší úsporněji - ten server běží přímo v hardware debug adaptéru. Což poněkud omezuje šířku záběru, běží to s velmi omezenými prostředky, takže nelze chtít zázraky. Nicméně je to velmi povedený kousek firmware. Je sice zaměřen především na procesory STM32, na němž je postaven, ladit se však dají i jiné. Předmětem mého zájmu bylo, zda by nešlo tento firmware trochu upravit, aby běžel na NXP procesoru LPC11U24. Ten má totiž USB stack postaven jako knihovnu, vypálenou přímo do ROM, takže se s tím není nutné tak podrobně zaobírat.</p>
<h1><a class="anchor" id="sectB"></a>
Co vše se tedy změnilo.</h1>
<p>Skoro všechno. Aby se to vešlo do omezené flash i ram, bylo potřeba spoustu věcí vyházet. Chtěl jsem to především na ladění Cortex-M0 (a možná i vyšších, ale stále ARM), takže jsem vyhodil JTAG. Cortexy se dají ladit po SWD, takže potřebujeme jen 2 dráty a zem. To je sice trochu omezující (chtělo by to ještě reset), ale dá se s tím žít. Větší škoda bylo vyhodit virtuální sériový port, ten je pro ladění o něco potřebnější. Ten sice jde do projektu přidat, ale je s tím víc problémů než užitku. No a protože SWD, tak není ani multitarget. Není potřeba. Není potřeba ani DFU, NXP to řeší pomocí MSC (disk), což je sice efektnější, ale má svá úskalí (zde snad vyřešena).</p>
<p>Nakonec to celé dopadlo tak, že jsem to přepsal do C++. Některé kusy kódu byly v čistém C docela dost zamotané a tak jsem je ani já úplně nepochopil. Ona je to docela jednoduchá skládačka z objektů, ale když píšeme objekty v C a dělá na tom více lidí, vznikne dost velký guláš. C++ je na tom o poznání lépe a velikost kódu neroste nijak dramaticky.</p>
<p>Dále bylo potřeba trochu pozměnit přístup k handshakingu na USB. NXP driver to dělá tak, že při příjmu setrvá v přerušení dokud nejsou data zpracována, což korektně pozastaví endpoint. Původní metoda zpracovávala data v hlavní smyčce a případné pozastavení si uměla vynutit. To se mi na NXP nepovedlo. Takže zůstáváme v přerušení, kde se generuje i odpověď na gdb paket. V main() je jediná metoda, která zjišťuje, zda target procesor běží. Ono to zase tak moc nevadí, jen je nutné mít dost dlouhou výstupní frontu, aby se do ní vše vešlo. Samotné gdb je inteligentní - na začátku se zeptá jak dlouhé pakety umí připojený adaptér zpracovat a pak používá maximálně tuto délku. Problémem jsou pakety, kterými odpovídá uživatelský monitor (např. příkaz monitor help). Takže kvůli této blbosti musí být výstupní fronta dlouhá. Zde jsou samotné gdb pakety zkráceny na 256 bytů, což zdá se stačí.</p>
<h1><a class="anchor" id="sectC"></a>
Paměť.</h1>
<p>Takže se dostáváme k rozložení RAM. Lze to celé natěsnat do 8kB. Samotné statické třídy, ze kterých je to postaveno moc místa nezabírají. Ta výstupní fronta má 1kB, což je pro gdb pakety dostatečná rezerva a když přeteče zase tak moc se neděje - hláška se nevypíše celá, server však běží dál. Dále je v .bss heap o velikosti 3kB, kde je celý target a některá data různých těch sprintf, u kterých je těžké předem určit délku. A i ta výstupní fronta. Od 4kB je oblast USB driverů o níž toho víme dost málo, ale nebude zabírat víc jak 2kB - to je délka USB oblasti některých procesorů. Předpokládá se, že tato oblast k dispozizi není - pokud by byla, je možné přesunout drivery tam (./lpc11/rom/usbclass.h, metoda init(), případně pokud nepoužijeme ROM drivery ./lpc11/usb/usbhw.h). Poslední 2kB zabírá stack, měl by být dost velký, protože některé metody mají na stacku dost velká pole dat.</p>
<h1><a class="anchor" id="sectDD"></a>
Struktura adresářů, firmware a ladění.</h1>
<ol type="1">
<li>kořen, kde je i Makefile, obsahuje jen komentář v <a class="el" href="main_8h_source.html">main.h</a>.</li>
<li>./src Společné třídy pro firmware i ladění.</li>
<li>./inc Společné hlavičky pro firmware i ladění.</li>
<li>./lpc11 Obsahuje třídy a hlavičky jen pro firmware.<ol type="a">
<li>rom Soubory pro použití ROM driverů USB.</li>
<li>usb Soubory pro vlastní driver USB. NXP má na webu zdrojáky, ale je to psáno pro Keil překladač a bylo nutno to trochu upravit. Podle toho, jak to bylo původně napsáno bych tomu moc nevěřil. Nicméně to celkem chodí.</li>
</ol>
</li>
<li>./i386 Obsahuje třídy a hlavičky pro ladění na PC pod OS Linux.</li>
<li>./lib Obsahuje pomocné utility pro firmware, včetně zdrojáků a ld skriptu.</li>
<li>./dbg Zde je pomocný firmware pro ladění na PC.</li>
<li>./com Zde je samostatný převodník USB &lt;-&gt; USART</li>
<li>./cmsis je CMSIS.</li>
<li>./product obsahuje 2 binární soubory pro LPC11U24,34 nejméně 32KB flash / 8KB ram.<ol type="a">
<li>serial.bin - kompletní probe se sériovým portem, používá ty Keil drivery. Je vcelku použitelné (tedy pod Linuxem), ale sériový port má své mouchy. Prostě je to moc věcí najednou.</li>
<li>probe.bin používá ROM drivery, nemá sériový port a tedy je to spolehlivější. Pro většinu věcí úplně postačí.</li>
</ol>
</li>
<li>./stm32/f4 Obsahuje třídy a hlavičky pro port na <a class="el" href="classSTM32F4.html">STM32F4</a> Discovery.</li>
</ol>
<p>Struktura programu vypadá na první pohled složitě, ale je dost prostá. Základem je třída <a class="el" href="classBaseLayer.html" title="[BaseLayer example] ">BaseLayer</a>, pomocí níž jsou propojeny tyto části: </p>
<div align="center">
<img src="dot_inline_dotgraph_1.png" alt="dot_inline_dotgraph_1.png" border="0" usemap="#dot_inline_dotgraph_1.map"/>
<map name="dot_inline_dotgraph_1.map" id="dot_inline_dotgraph_1.map"></map>
</div>
<ol type="1">
<li><a class="el" href="classSwdp.html" title="Fyzický přístup na SWD piny. ">Swdp</a> zajišťuje fyzický přístup na SWD piny. Je to jeden konec řetězu.</li>
<li><a class="el" href="classGdbServer.html" title="Vlastní obsluha gdb paketů. Nejpodstatnější část celého programu. Vše se děje v přerušení od USB...">GdbServer</a> je jádrem celého problému.</li>
<li><a class="el" href="classGdbPacket.html" title="Mezivrsta paketů gdb. Ořezává a vytváří prefix, zpracuje escape sekvence a vyhodnocuje (a doplňuje) k...">GdbPacket</a> je mezivrstva obsluhující jednotlivé pakety gdb.</li>
<li><a class="el" href="classCDClass.html" title="Virtuální sériový port jako třída. ">CDClass</a> je druhý konec řetězce (v PC je to síťový socket), ve vlastním firmware je to opravdu virtuální sériový port.</li>
</ol>
<p>Jádrem je jak bylo uvedeno <a class="el" href="classGdbServer.html" title="Vlastní obsluha gdb paketů. Nejpodstatnější část celého programu. Vše se děje v přerušení od USB...">GdbServer</a>, bude proto popsán samostatně. Vygeneruj si dokumentaci pomocí <a href="http://www.stack.nl/~dimitri/doxygen/">doxygen</a>. Obsahuje především vlastní <a class="el" href="classTarget.html">Target</a>, který je zde vytvářen dynamicky metodou Scan() - gdb příkaz "monitor scan".</p>
<p>Takže pokud chceme ladit firmware na PC, což je daleko příjemnější, spustíme Makefile v ./dbg a vytvořený firmware.bin nalejeme do LPC11U24 (nebo 34 podle libosti - konečný cíl by měl mít 32kB flash a 8kB ram). V kořenovém Makefile odkomentujeme dáme PLATFORM ?= i386 a spustíme. Výsledný firmware.elf jde pod Linuxem spustit jako gdb server na portu 3333. Tedy pokud máme připojen na USB ten připravený procesor jako /dev/ttyACM0. Takže pokud máme i připojené piny (viz ./lpc11/config.h) na laděný target, funguje to podobně jako OpenOCD. Takto lze ladit vše, co je v ./src (a ./inc). Když máme odladěno, změníme zpět komentáře v Makefile a vytvoříme výsledný firmware.bin, který už má v sobě gdb server. Z postupu je vidět, že C++ umožňuje dost dobře využívat jednou napsaný kód v různých aplikacích prakticky bez zásahu do zdrojáků. Vhodnou strukturou adresářů se lze vyhnout používání těch ifdef, které kód zbytečně znepřehledňují.</p>
<p>Kontrolní sumy vektorů, pro LPC11... dost důležité by měly sedět, takže stačí binárky opravdu jen prostě zkopírovat.</p>
<h1><a class="anchor" id="sectD"></a>
Dosažené výsledky.</h1>
<p>Targety STM32F051 a LPC11U24, 34 jsem mohl otestovat, jiné nemám k dispozizi. Dá se říct, že chodí debug pod gdb dost dobře, lze natáhnout program do ram i flash pomocí "load", gdb si samo určí, kam ho umístí. Krokování delších smyček je problematické, gdb to provádí po jednotlivých instrukcích a po každé instrukci vymění se serverem spoustu dat, takže to trvá dlouho. Protože se to dá pomocí CTRL-C zastavit, zase tak moc to nevadí. Testy by chtěly provést opravdu důkladně, gdb je složité a popravdě všechny příkazy neznám. Běžně vystačím s "run", "continue", "step", "next", "breakpoint", příp. výpisem kusu paměti pomocí "x", "print". Vypisovat registry periférií (na rozdíl od základních registrů procesoru) nejde, xml mapa paměti tuto část neobsahuje. Snad je to tak lépe, ono totiž i pouhé přečtení nějakého registru může změnit chování periferie.</p>
<p>Celé to gdb používám pouze v příkazovém řádku. Těch pár potřebných příkazů se dá snadno naučit a pak je alespoň vidět, co se tam děje, případně kde to zamrzlo. Integrovat to celé do IDE je sice pěkné, ale musíme počítat s tím, že je to rozsáhlý software a mohou v něm být chyby. V IDE pak zjistíme jen to, že to nefunguje. A pak zbývá jen nadávat autorům. Dobré je udělat si v $HOME soubor .gdbinit, ve kterém pak může být např. (psát pořád to "tar ext /home/mrazik/.probe/COM3" je otravné): </p>
<div class="fragment"><div class="line">set prompt Kizarm\\&gt;\040</div>
<div class="line"><span class="preprocessor"># /home/mrazik/.probe/COM3 je link na napr.</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># /dev/serial/by-id/usb-Mrazik_labs._Kizarm_Probe_1.1_00003-if00</span></div>
<div class="line"><span class="preprocessor">tar ext /home/mrazik/.probe/COM3</span></div>
</div><!-- fragment --><p> a pak jednoduše ladíme (STM32F051 v RAM) pomocí </p>
<div class="fragment"><div class="line">XYZ$ arm-none-eabi-gdb firmware.elf </div>
<div class="line">GNU gdb (GNU Tools <span class="keywordflow">for</span> ARM Embedded Processors) ... &lt;neni podstatne&gt;</div>
<div class="line">Reading symbols from /home/mrazik/Public/Arm/Prj/st-cpp/firmware.elf...done.</div>
<div class="line">Kizarm\&gt; mon scan</div>
<div class="line">Core Id: 0x0BB11477</div>
<div class="line"><a class="code" href="classTarget.html">Target</a>: STM32F0xx</div>
<div class="line">Kizarm\&gt; att 1</div>
<div class="line">Attaching to program: /home/mrazik/Public/Arm/Prj/st-cpp/firmware.elf, Remote target</div>
<div class="line">0xfffffffe in ?? ()</div>
<div class="line">Kizarm\&gt; load</div>
<div class="line">Loading section .text, size 0xc18 lma 0x20000000</div>
<div class="line">Loading section .data, size 0x4 lma 0x20000c18</div>
<div class="line">Loading section ._user_heap_stack, size 0x400 lma 0x20000d10</div>
<div class="line">Start address 0x20000948, load size 4124</div>
<div class="line">Transfer rate: 23 KB/sec, 206 bytes/write.</div>
<div class="line">Kizarm\&gt; r</div>
<div class="line">The program being debugged has been started already.</div>
<div class="line">Start it from the beginning? (y or n) y</div>
<div class="line"></div>
<div class="line">Starting program: /home/mrazik/Public/Arm/Prj/st-cpp/firmware.elf </div>
<div class="line">^C</div>
<div class="line">Program received signal SIGINT, Interrupt.</div>
<div class="line">0x200002f0 in __WFI () at ../../lib/cmsis/inc/core_cmInstr.h:282</div>
<div class="line">282       __ASM volatile (&quot;wfi&quot;);</div>
<div class="line">Kizarm\&gt; bt</div>
<div class="line"><span class="preprocessor">#0  0x200002f0 in __WFI () at ../../lib/cmsis/inc/core_cmInstr.h:282</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#1  main () at main.cpp:89</span></div>
<div class="line"><span class="preprocessor"></span>Kizarm\&gt; det</div>
<div class="line">Detaching from program: /home/mrazik/Public/Arm/Prj/st-cpp/firmware.elf, Remote target</div>
<div class="line">Kizarm\&gt; q</div>
</div><!-- fragment --><h1><a class="anchor" id="sectE"></a>
Zbývá dodělat.</h1>
<p>U STM32F051 jsem nezkoušel měnit option byty, snad to funguje. <a class="el" href="classTarget.html">Target</a> STM32F407 funguje také, ale také není úplně otestován (option, flash). Asi by bylo dobře dodělat i target řady LPC8xx, ale zatím to nepotřebuji.</p>
<p>Ten sériový port jsem pokusně přidal jako druhé rozhraní kompozitního zařízení USB. Je to default vypnuto (1. řádek ./lpc11/makefile.inc), protože ten virtuální sériový port se s ROM drivery chová dost podivně. Nelze přepnout parametry linky (např. baudrate). To sice není moc potřeba, ale chodit by to mělo. Takže tady je slabina. Ostatně původní blackmagic má ten sériový port také poměrně problematický. USB je složité a nevím, jestli jsou vůbec správně deskriptory toho složeného zařízení. Další dost velký problém je, že ROM drivery patrně nepočítají s tím, že by od jedné třídy USB zařízení někdo vytvářel více instancí. Takže zprávy po endpointu 0 chodí zmateně. Zřejmě bude lépe ROM drivery nepoužívat, použít USB stack od Keilu. Virtuální sériový port pokud je potřeba lze udělat jako samostatný firmware - viz. adresář ./com. Stejně bych neuměl přiohnout příslušný inf soubor pro Windows. Takhle lze použít původní NXP.</p>
<p>NXP - Keil drivery jsem konečně vyzkoušel a konstatuji, že to bylo dost práce s diskutabilním výsledkem. Alokace paměti pro endpointy ani zde není průhledná, takže i tady jsou kusy RAM, kde se asi něco děje, ale netušíme co. Alespoň funguje ten endpoint 0. Takže krátce o ladění těchto detailů. Před časem jsem se tím zabýval <a href="http://mujweb.cz/mrazik/usb/index.html">zde</a>. Mezitím se hodně změnilo v Linuxovém jádře, takže celý ten systém funguje asi už úplně jinak. Soubor usbem.c jsem zde ale zachoval, šlo to odladit na starším počítači. Je fakt, že bez toho by to byla práce pro vraha. Výsledek se použít dá (./product/serial.bin), zkoušel jsem to jen na Linuxu (Ubuntu 12.04 LTS), na jiném počítači se starší verzí Ubuntu to občas tuhne, což mohou působit ovladače. Pod Windows jsem nezkoušel ani ten původní firmware s ROM drivery, protoře žádné Windows nemám. Proto ani nepřikládám inf pro instalaci ovladačů. I když loni jsem zkoušel skoro stejný virtuální COM na XP a nebyly s tím žádné problémy. Kdo chce, tak si ten inf na stránkách NXP najde a vyzkouší. Vlastní ovladač je systémový usbser.sys (nebo tak nějak).</p>
<p>Nově doplněna jako platforma na které to může běžet <a class="el" href="classSTM32F4.html">STM32F4</a> Discovery. Není to sice nic užitečného, protože F4 je dělo na komára, ale ukazuje se, jak snadné je portovat to na jinou architekturu.</p>
<h1><a class="anchor" id="sectF"></a>
Zdrojáky.</h1>
<p>Jsou dostupné na sourceforge jen pomocí subversion : </p>
<div class="fragment"><div class="line">svn checkout svn:<span class="comment">//svn.code.sf.net/p/kizarmprobe/code/ kizarmprobe</span></div>
</div><!-- fragment --><h1><a class="anchor" id="sectG"></a>
Závěr.</h1>
<p>Tenhle kus kódu dokumentuje, že lze nacpat do poměrně malého a tedy i levného kontroleru dost složité zařízení. Psát to v C++ se zdá možná zbytečné, ale je to dost užitečné - získá to poněkud na přehlednosti a tedy i rozšířitelnosti. Doufám, že se bude líbit a někomu to pomůže v jeho vlastní činnosti. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generováno so 27. čer 2015 11.09:08 pro projekt KizarmProbe. programem &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
